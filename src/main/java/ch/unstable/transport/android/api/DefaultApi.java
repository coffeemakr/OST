/**
 * Trasport API
 * The Transport API allows interested developers to build their own applications using public timetable data, whether they're on the web, the desktop or mobile devices. The aim of this inofficial API is to cover public transport within Switzerland. If you are looking for an officially supported source or need to download all data e.g in GTFS format, please check opendata.swiss. The source code of the Transport API can be found on GitHub, please ask any technical questions there. If you need a direct contact write an email to transport@opendata.ch. In order to be kept update on the future development of this API, please subscribe to our low-traffic Google Group.
 *
 * OpenAPI spec version: 1
 * Contact: transport@opendata.ch
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package ch.unstable.transport.android.api;

import ch.unstbale.transdport.android.ApiInvoker;
import ch.unstbale.transdport.android.ApiException;
import ch.unstbale.transdport.android.Pair;

import ch.unstable.transport.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import ch.unstable.transport.model.Connections;
import ch.unstable.transport.model.InlineResponse400;
import ch.unstable.transport.model.StationBoardResponse;
import ch.unstable.transport.model.Stations;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class DefaultApi {
  String basePath = "https://transport.opendata.ch/v1";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * 
  * Returns the next connections from a location to another.
   * @param from Specifies the departure location of the connection
   * @param to Specifies the arrival location of the connection
   * @param via Specifies up to five via locations.
   * @param date Date of the connection, in the format YYYY-MM-DD
   * @param time Time of the connection, in the format hh:mm
   * @param isArrivalTime defaults to 0, if set to 1 the passed date and time is the arrival time
   * @param transportations Only with x and y parameter. Transportation means; one or more of ice_tgv_rj, ec_ic, ir, re_d, ship, s_sn_r, bus, cableway, arz_ext, tramway_underground
   * @param limit 1 - 6. Specifies the number of connections to return. If several connections depart at the same time they are counted as 1.
   * @param page 
   * @param sleeper defaults to 0, if set to 1 only night trains containing beds are allowed, implies direct&#x3D;1
   * @param couchette defaults to 0, if set to 1 only night trains containing couchettes are allowed, implies direct&#x3D;1
   * @param bike defaults to 0, if set to 1 only trains allowing the transport of bicycles are allowed
   * @param accessibility Possible values are independent_boarding, assisted_boarding, and advanced_notice
   * @return Connections
  */
  public Connections connectionsGet (String from, String to, List<String> via, String date, String time, Integer isArrivalTime, List<String> transportations, Integer limit, Integer page, Integer sleeper, Integer couchette, Integer bike, String accessibility) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'from' is set
    if (from == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'from' when calling connectionsGet",
        new ApiException(400, "Missing the required parameter 'from' when calling connectionsGet"));
    }
    // verify the required parameter 'to' is set
    if (to == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'to' when calling connectionsGet",
        new ApiException(400, "Missing the required parameter 'to' when calling connectionsGet"));
    }

    // create path and map variables
    String path = "/connections";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "from", from));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "to", to));
    queryParams.addAll(ApiInvoker.parameterToPairs("csv", "via[]", via));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "date", date));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "time", time));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "isArrivalTime", isArrivalTime));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "transportations[]", transportations));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sleeper", sleeper));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "couchette", couchette));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "bike", bike));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accessibility", accessibility));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Connections) ApiInvoker.deserialize(localVarResponse, "", Connections.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * 
   * Returns the next connections from a location to another.
   * @param from Specifies the departure location of the connection   * @param to Specifies the arrival location of the connection   * @param via Specifies up to five via locations.   * @param date Date of the connection, in the format YYYY-MM-DD   * @param time Time of the connection, in the format hh:mm   * @param isArrivalTime defaults to 0, if set to 1 the passed date and time is the arrival time   * @param transportations Only with x and y parameter. Transportation means; one or more of ice_tgv_rj, ec_ic, ir, re_d, ship, s_sn_r, bus, cableway, arz_ext, tramway_underground   * @param limit 1 - 6. Specifies the number of connections to return. If several connections depart at the same time they are counted as 1.   * @param page    * @param sleeper defaults to 0, if set to 1 only night trains containing beds are allowed, implies direct&#x3D;1   * @param couchette defaults to 0, if set to 1 only night trains containing couchettes are allowed, implies direct&#x3D;1   * @param bike defaults to 0, if set to 1 only trains allowing the transport of bicycles are allowed   * @param accessibility Possible values are independent_boarding, assisted_boarding, and advanced_notice
  */
  public void connectionsGet (String from, String to, List<String> via, String date, String time, Integer isArrivalTime, List<String> transportations, Integer limit, Integer page, Integer sleeper, Integer couchette, Integer bike, String accessibility, final Response.Listener<Connections> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'from' is set
    if (from == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'from' when calling connectionsGet",
        new ApiException(400, "Missing the required parameter 'from' when calling connectionsGet"));
    }
    // verify the required parameter 'to' is set
    if (to == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'to' when calling connectionsGet",
        new ApiException(400, "Missing the required parameter 'to' when calling connectionsGet"));
    }

    // create path and map variables
    String path = "/connections".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "from", from));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "to", to));
    queryParams.addAll(ApiInvoker.parameterToPairs("csv", "via[]", via));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "date", date));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "time", time));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "isArrivalTime", isArrivalTime));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "transportations[]", transportations));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "page", page));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "sleeper", sleeper));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "couchette", couchette));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "bike", bike));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "accessibility", accessibility));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Connections) ApiInvoker.deserialize(localVarResponse,  "", Connections.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Query Locations
  * Returns the matching locations for the given parameters. Either &#x60;query&#x60; or ( &#x60;x&#x60; and &#x60;y&#x60; ) are required.  The locations in the response are scored to determine which is the most exact location.  This method can return a refine response, what means that the request has to be redone. 
   * @param query Specifies the location name to search for (e.g. Basel)
   * @param x Latitude (e.g. &#x60;47.476001&#x60;)
   * @param y Longitude (e.g. &#x60;8.306130&#x60;)
   * @param type Only with query parameter. Specifies the location type, possible types are:  * all (default): Looks up for all types of locations  * station: Looks up for stations (train station, bus station)  * poi: Looks up for points of interest (Clock tower, China garden)  * address: Looks up for an address (Zurich Bahnhofstrasse 33) 
   * @param transportations Only with x and y parameter. Transportation means; one or more of ice_tgv_rj, ec_ic, ir, re_d, ship, s_sn_r, bus, cableway, arz_ext, tramway_underground
   * @return Stations
  */
  public Stations locationsGet (String query, String x, String y, String type, List<String> transportations) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/locations";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "query", query));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "x", x));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "y", y));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "type", type));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "transportations[]", transportations));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (Stations) ApiInvoker.deserialize(localVarResponse, "", Stations.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Query Locations
   * Returns the matching locations for the given parameters. Either &#x60;query&#x60; or ( &#x60;x&#x60; and &#x60;y&#x60; ) are required.  The locations in the response are scored to determine which is the most exact location.  This method can return a refine response, what means that the request has to be redone. 
   * @param query Specifies the location name to search for (e.g. Basel)   * @param x Latitude (e.g. &#x60;47.476001&#x60;)   * @param y Longitude (e.g. &#x60;8.306130&#x60;)   * @param type Only with query parameter. Specifies the location type, possible types are:  * all (default): Looks up for all types of locations  * station: Looks up for stations (train station, bus station)  * poi: Looks up for points of interest (Clock tower, China garden)  * address: Looks up for an address (Zurich Bahnhofstrasse 33)    * @param transportations Only with x and y parameter. Transportation means; one or more of ice_tgv_rj, ec_ic, ir, re_d, ship, s_sn_r, bus, cableway, arz_ext, tramway_underground
  */
  public void locationsGet (String query, String x, String y, String type, List<String> transportations, final Response.Listener<Stations> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/locations".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "query", query));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "x", x));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "y", y));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "type", type));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "transportations[]", transportations));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((Stations) ApiInvoker.deserialize(localVarResponse,  "", Stations.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * 
  * Returns the next connections leaving from a specific location.
   * @param station Specifies the location of which a stationboard should be returned
   * @param id The id of the station whose stationboard should be returned.    Alternative to the station parameter; one of these two is required.  If both an id and a station are specified the id has precedence.   
   * @param limit Number of departing connections to return.  This is not a hard limit - if multiple connections leave at the same time it&#39;ll return any connections that leave at the same time as the last connection within the limit. For example: limit&#x3D;4 will return connections leaving at:   * 19:30   * 19:32   * 19:32   * 19:35   * 19:35  Because one of the connections leaving at 19:35 is within the limit, all connections leaving at 19:35 are shown. 
   * @param transportations Only with x and y parameter. Transportation means; one or more of ice_tgv_rj, ec_ic, ir, re_d, ship, s_sn_r, bus, cableway, arz_ext, tramway_underground
   * @param datetime Date and time of departing connections, in the format YYYY-MM-DD hh:mm.
   * @param type 
   * @return StationBoardResponse
  */
  public StationBoardResponse stationboardGet (String station, String id, Integer limit, List<String> transportations, String datetime, String type) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;

    // create path and map variables
    String path = "/stationboard";

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "station", station));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "id", id));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "transportations[]", transportations));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "datetime", datetime));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "type", type));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] {  };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (StationBoardResponse) ApiInvoker.deserialize(localVarResponse, "", StationBoardResponse.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * 
   * Returns the next connections leaving from a specific location.
   * @param station Specifies the location of which a stationboard should be returned   * @param id The id of the station whose stationboard should be returned.    Alternative to the station parameter; one of these two is required.  If both an id and a station are specified the id has precedence.      * @param limit Number of departing connections to return.  This is not a hard limit - if multiple connections leave at the same time it&#39;ll return any connections that leave at the same time as the last connection within the limit. For example: limit&#x3D;4 will return connections leaving at:   * 19:30   * 19:32   * 19:32   * 19:35   * 19:35  Because one of the connections leaving at 19:35 is within the limit, all connections leaving at 19:35 are shown.    * @param transportations Only with x and y parameter. Transportation means; one or more of ice_tgv_rj, ec_ic, ir, re_d, ship, s_sn_r, bus, cableway, arz_ext, tramway_underground   * @param datetime Date and time of departing connections, in the format YYYY-MM-DD hh:mm.   * @param type 
  */
  public void stationboardGet (String station, String id, Integer limit, List<String> transportations, String datetime, String type, final Response.Listener<StationBoardResponse> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;


    // create path and map variables
    String path = "/stationboard".replaceAll("\\{format\\}","json");

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "station", station));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "id", id));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "limit", limit));
    queryParams.addAll(ApiInvoker.parameterToPairs("multi", "transportations[]", transportations));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "datetime", datetime));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "type", type));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] {  };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((StationBoardResponse) ApiInvoker.deserialize(localVarResponse,  "", StationBoardResponse.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
